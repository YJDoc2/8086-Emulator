use crate::util::preprocessor_util as util;
use util::{Label,LabelType};
use crate::vm::MB;
use regex::{Regex,Captures};
use crate::error;
use lalrpop_util::ParseError;



// NOTES
// quote_ tokens are used for creating case ignoring names, as r"(capital case|small case)" generates ambiguity
//      if not this, either manually implement both with same code, else try r"(capital case|small case) " (with space)
//      but that can have issues as well
//
// name_string is a string that can be used for macro, function or label name, must start with _ or alphabet
// general_string is string that accepts name_string, number

grammar<'s>(context:&'s mut util::Context,out:&'s mut util::Output);

pub Preprocessor:() ={
    data_directives? Code? =>()
}

Code:() = {
    code_directives,
    label,
    opcodes,
    procedure,
    print_stmt,
    Code code_directives,
    Code opcodes,
    Code procedure,
    Code print_stmt,
    Code label,
    
}

// ---------------------------------------------------------------------------------------------

// Assembler Data Directives

// Collective of all data directives
data_directives:() = {
    set_directive,
    db_directive,
    dw_directive,
    data_directives set_directive,
    data_directives db_directive,
    data_directives dw_directive,
}

// Set directive : used to set the DS value manually
set_directive:() = {
    quote_set <n:u_word_num> => {
        out.data.push(format!("set {}",n));
    }
}

quote_set:()={
    "set",
    "SET"
}

// DB directive
db_directive:() = {
    // Set single value
    <start:@L> <l:label?> quote_db <n:s_byte_num> =>{
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("db {}",n));
        // Increment the data counter
        context.data_counter += 1;
    },
    // Set array value initialized to 0
    <start:@L> <l:label?> quote_db "["<n:u_word_num>"]" =>{
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("db [{}]",n));
        // Increment the data counter
        context.data_counter += n;
    },
    // Set array value initialized to value
    <start:@L> <l:label?> quote_db "["<v:s_byte_num> ";" <n:u_word_num>"]" =>{
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("db [{} ; {}]",v,n));
        // Increment the data counter
        context.data_counter += n;
    },
    // set string
    <start:@L> <l:label?> quote_db <q:r#""[[:ascii:]]*""#> <end:@R> =>?{
        if q.len() > (u16::MAX-10) as usize{ // 10 is arbitrary
            return error!(start,end,format!("Single string can have at most {} characters, overflowing this would set the labels incorrectly, consider splitting string and using set to change location counter",u16::MAX-10));
        }
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("db {}",q));
        // Increment the data counter
        context.data_counter += (q.len()-2) as u16; // -2 for the quotes
        Ok(())
    },
}

quote_db:() = {
    "DB",
    "db",
}

// DW directive
dw_directive:() = {
    // Set single value
    <start:@L> <l:label?> quote_dw <n:s_word_num> =>{
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("dw {}",n));
        // Increment the data counter
        context.data_counter += 2;
    },
    // Set array value initialized to 0
    <start:@L> <l:label?> quote_dw "["<n:u_word_num>"]" =>{
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("dw [{}]",n));
        // Increment the data counter
        context.data_counter += 2*n;
    },
    // Set array value initialized to value
    <start:@L> <l:label?> quote_dw "["<v:s_word_num> ";" <n:u_word_num>"]" =>{
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("dw [{} ; {}]",v,n));
        // Increment the data counter
        context.data_counter += 2*n;
    },
    //set string
    <start:@L> <l:label?> quote_dw <q:r#""[[:ascii:]]*""#> <end:@R> =>?{
        if q.len() > ((u16::MAX/2)-10) as usize { // 10 is arbitrary
            return error!(start,end,format!("Single string can have at most {} characters, overflowing this would set the labels incorrectly, consider splitting string and using set to change location counter",(u16::MAX/2)-10));
        }
        if let Some(l) = l{
            context.label_map.insert(l,Label::new(LabelType::DATA,start,context.data_counter as usize));
        }
        out.data.push(format!("dw {}",q));
        // Increment the data counter
        context.data_counter += (2*(q.len()-2)) as u16; // -2 for the quotes
        Ok(())
    },
}

quote_dw:() = {
    "dw",
    "DW"
}


// ---------------------------------------------------------------------------------------------

// Assembler code Directives

// Collective of all code directives
code_directives:() = {
    macro_def,
    macro_use,
}

// As lalrpop does not support optional token, and makes it an ambiguity error 
// if we use r"(MACRO|macro)" we will have to use this double declaration :(
// Closing bracket is counted and removed in raw_code
macro_def:() = {
    quote_macro <name:name_string> "(" <params:CommaSepList<name_string>> ")" "->" <s:r"[_a-zA-Z0-9\[\]\(\), ]*<-"> =>{
        let mut r =s[0..s.len()-2].to_owned();
        // maybe try making single regex of all params and replace, somehow
        for (i,p) in params.iter().enumerate(){
            let pat = format!(r"\b{}\b",p);
            let re = Regex::new(&pat).unwrap();
            r = re.replace_all(&r,|caps:&Captures|{
                format!("{{{}}}",i)
            }).to_string();
        }
        context.macro_map.insert(name,r);
    }
}

quote_macro:()={
    "MACRO",
    "macro"
}


macro_use:() = {
    <start:@L> <l:r"[_a-zA-Z][_a-zA-Z0-9]*"> "(" <params:CommaSepList<general_string>> ")" <end:@R> =>? {
        match context.macro_map.get(l){
            Some(value)=>{
                let mut r = value.clone();
                // TODO Maybe optimise this later
                // maybe try making single regex of all params and replace, somehow
                for (i,p) in params.iter().enumerate(){
                    let pat = format!("{{{}}}",i);
                    r = r.replace(&pat,&p);
                }
                if context.macro_nesting_counter.contains(l) {
                    return error!(start,end,"Recursive macros are not allowed".to_owned());
                }else{
                    context.macro_nesting_counter.insert(l.to_string());
                }
                let p = PreprocessorParser::new();
                context.mapper.set_source(start);
                
                context.mapper.lock_source();
                let o = p.parse(context,out,&r);
                context.mapper.unlock_source();
                context.macro_nesting_counter.remove(l);
                match o{
                    Ok(_)=>Ok(()),
                    Err(e)=>{
                        let error = if let ParseError::UnrecognizedToken{token: (ref start, ref token, ref end),ref expected} = e{
                            if token.1 == "" {
                                format!("{}",expected[0])
                            }else{
                                format!("Unexpected Token {}",token)
                            }
                        }else{
                            format!("{}",e)
                        };
                        error!(start,end,format!("Error in Macro Expansion :\nExpanded Macro : {}\nError: {}",r,error))
                    }
                }
            },
            None => error!(start as usize,start +l.len(),"Macro not defined".to_owned()),
        }
    }
}

procedure:() = {
    <start:@L> proc_def "{" proc_contents "}" <end:@R> =>{
        out.code.push("ret".to_owned());
        context.mapper.add_entry(end);
    }
}

proc_def:() = {
    <start:@L> quote_proc <n:name_string> <end:@R> =>? {
        match context.fn_map.get(&n){
            Some(_) => error!(start,end,format!("Procedure {} already declared",n)),
            None => {context.fn_map.insert(n,out.code.len());Ok(())}
        }
    }
}

proc_contents:() = {
    opcodes,
    macro_use,
    proc_contents opcodes,
    proc_contents macro_use,
}

quote_proc:()={
    "def",
    "DEF"
}

// Offset is along with num

print_stmt:() = {
    <start:@L> quote_print quote_flags => {
        out.code.push("print flags".to_owned());
        context.mapper.add_entry(start);
    },
    <start:@L>  quote_print quote_reg => {
        out.code.push("print reg".to_owned());
        context.mapper.add_entry(start);
    },
    <start:@L> quote_print quote_mem <s:raw_addr> "->" <e:raw_addr> => {
        out.code.push(format!("print mem {} -> {}",s,e));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_print quote_mem <s:raw_addr> ":" <e:raw_addr> <end:@R>=>? {
        if s+e >= MB{
            return error!(start,end,format!("End address is greater than memory address space : {} + {} = {} > {}",s,e,s+e,MB-1))
        }
        out.code.push(format!("print mem {} : {}",s,e));
        context.mapper.add_entry(start);
        Ok(())
    },
    <start:@L> quote_print quote_mem  ":" <o:raw_addr> => {
        out.code.push(format!("print mem : {}",o));
        context.mapper.add_entry(start);
    },
}

quote_print:() = {
    "PRINT",
    "print"
}

quote_flags:() = {
    "FLAGS",
    "flags"
}

quote_reg:() = {
    "REG",
    "reg"
}

quote_mem:() = {
    "MEM",
    "mem"
}

// ---------------------------------------------------------------------------------------------

// Assembler opcodes
opcodes:()={
    control,
    transfer,
    bit_manipulation,
    arithmetic,
    string,
    data_transfer,
}

// ----------------------------------
// Data Transfer Instructions

data_transfer:() = {
    singleton_data_transfer,
    xchg,
    op_in,
    op_out,
    pop,
    push,
    load_ptr,
    lea,
    mov
}

mov:() ={
    // reg,reg
    <start:@L> quote_mov <r1:gen_byte_reg> "," <r2:gen_byte_reg> =>{
        out.code.push(format!("mov {},{}",r1,r2));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <r1:gen_word_reg> "," <r2:gen_word_reg> =>{
        out.code.push(format!("mov {},{}",r1,r2));
        context.mapper.add_entry(start);
    },
    
    //reg,mem
    <start:@L> quote_mov <r:gen_byte_reg> "," quote_byte_length <m:memory_addr> =>{
        out.code.push(format!("mov {}, byte {}",r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <r:gen_word_reg> "," quote_word_length <m:memory_addr> =>{
        out.code.push(format!("mov {}, word {}",r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <r:gen_byte_reg> "," <l:byte_label> =>{
        out.code.push(format!("mov {}, byte {}",r,l));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <r:gen_word_reg> "," <l:word_label> =>{
        out.code.push(format!("mov {},word {}",r,l));
        context.mapper.add_entry(start);
    },

    // mem,reg
    <start:@L> quote_mov quote_byte_length <m:memory_addr> "," <r:gen_byte_reg> =>{
        out.code.push(format!("mov byte {},{}",m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov quote_word_length <m:memory_addr> "," <r:gen_word_reg> =>{
        out.code.push(format!("mov word {},{}",m,r));
        context.mapper.add_entry(start);
    },

    <start:@L> quote_mov  <l:byte_label> "," <r:gen_byte_reg> =>{
        out.code.push(format!("mov byte {},{}",l,r));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov  <l:word_label> "," <r:gen_word_reg> =>{
        out.code.push(format!("mov word {},{}",l,r));
        context.mapper.add_entry(start);
    },

    //reg , immediate
    <start:@L> quote_mov <r:gen_byte_reg> "," <n:s_byte_num> =>{
        out.code.push(format!("mov {},{}",r,n));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <r:gen_word_reg> "," <n:s_word_num> =>{
        out.code.push(format!("mov {},{}",r,n));
        context.mapper.add_entry(start);
    },

    // mem, immediate
    <start:@L> quote_mov quote_byte_length <m:memory_addr> "," <n:s_byte_num> =>{
        out.code.push(format!("mov byte {}, {}",m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov quote_word_length <m:memory_addr> "," <n:s_word_num> =>{
        out.code.push(format!("mov word {},{}",m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <m:byte_label> "," <n:s_byte_num> =>{
        out.code.push(format!("mov byte {}, {}",m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov  <m:word_label> "," <n:s_word_num> =>{
        out.code.push(format!("mov word {},{}",m,n));
        context.mapper.add_entry(start);
    },

    // seg-reg , reg
    <start:@L> quote_mov  <sr:seg_reg> "," <r:gen_word_reg> =>{
        out.code.push(format!("mov {},{}",sr,r));
        context.mapper.add_entry(start);
    },

    //reg, seg-reg
    <start:@L> quote_mov <r:gen_word_reg>  ","  <sr:seg_reg>  =>{
        out.code.push(format!("mov {},{}",r,sr));
        context.mapper.add_entry(start);
    },

    // seg-reg , mem
    <start:@L> quote_mov quote_word_length <m:memory_addr> "," <sr:seg_reg> =>{
        out.code.push(format!("mov word {},{}",m,sr));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov  <l:word_label> "," <sr:seg_reg> =>{
        out.code.push(format!("mov word {},{}",l,sr));
        context.mapper.add_entry(start);
    },

    // mem, seg-reg

    <start:@L> quote_mov  <sr:seg_reg> "," quote_word_length <m:memory_addr> =>{
        out.code.push(format!("mov {}, word {}",sr,m));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_mov <sr:seg_reg> "," <l:word_label>=>{
        out.code.push(format!("mov {}, word {}",sr,l));
        context.mapper.add_entry(start);
    },
}

seg_reg:String={
    "ES" => "es".to_owned(),
    "es" => "es".to_owned(),
    "DS" => "ds".to_owned(),
    "ds" => "ds".to_owned(),
    "SS" => "ss".to_owned(),
    "ss" => "ss".to_owned(),
    "CS" => "cs".to_owned(),
    "cs" => "cs".to_owned(),
    
}


quote_mov:() ={
    "MOV",
    "mov",
}

singleton_data_transfer:() = {
    <start:@L> <q:quote_singleton_transfer> => {
        out.code.push(q);
        context.mapper.add_entry(start);
    },
}

quote_singleton_transfer:String ={
    "LAHF" => "lahf".to_owned(),
    "lahf" => "lahf".to_owned(),
    "SAHF" => "sahf".to_owned(),
    "sahf" => "sahf".to_owned(),
    "PUSHF" => "pushf".to_owned(),
    "pushf" => "pushf".to_owned(),
    "POPF" => "popf".to_owned(),
    "popf" => "popf".to_owned(),
    "XLAT" => "xlat".to_owned(),
    "xlat" => "xlat".to_owned(),
}

xchg:() = {
    // reg, reg
    <start:@L> <q:quote_xchg> <r1:gen_byte_reg> "," <r2:gen_byte_reg>  => {
        out.code.push(format!("xchg {} ,{}",r1,r2));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <r1:gen_word_reg> "," <r2:gen_word_reg>  => {
        out.code.push(format!("xchg {} ,{}",r1,r2));
        context.mapper.add_entry(start);
    },
    // mem, reg
    // as the operands could be in any order, this accepts both reg,mem and mem,reg 
    // but converts it to single format mem, reg
    <start:@L> <q:quote_xchg> quote_byte_length <m:memory_addr> "," <r:gen_byte_reg>  => {
        out.code.push(format!("xchg byte {} ,{}",m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <r:gen_byte_reg> "," quote_byte_length <m:memory_addr>  => {
        out.code.push(format!("xchg byte {} ,{}",m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <r:gen_word_reg> "," quote_word_length <m:memory_addr> => {
        out.code.push(format!("xchg word {} ,{}",m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> quote_word_length <m:memory_addr> "," <r:gen_word_reg>=> {
        out.code.push(format!("xchg word {} ,{}",m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <l:byte_label> "," <r:gen_byte_reg>  => {
        out.code.push(format!("xchg byte {} ,{}",l,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <r:gen_byte_reg> ","  <l:byte_label>  => {
        out.code.push(format!("xchg byte {} ,{}",l,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <l:word_label> "," <r:gen_word_reg>  => {
        out.code.push(format!("xchg word {} ,{}",l,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_xchg> <r:gen_word_reg> "," <l:word_label> => {
        out.code.push(format!("xchg word {} ,{}",l,r));
        context.mapper.add_entry(start);
    },
    
}

quote_xchg:() = {
    "XCHG",
    "xchg",
}

// even tough in has operand type accumulator,byte num or accumulator,dx 
// as it is not supported anyway, this accepts all general registers
op_in:() = {
    <start:@L> quote_in gen_byte_reg "," u_byte_num =>? error!(start,start+2,"\'in\' is not supported.".to_owned()),
    <start:@L> quote_in gen_byte_reg "," gen_byte_reg =>? error!(start,start+2,"\'in\' is not supported.".to_owned()),
}

op_out:() = {
    <start:@L> quote_out u_byte_num "," gen_byte_reg =>? error!(start,start+2,"\'in\' is not supported.".to_owned()),
    <start:@L> quote_out gen_byte_reg "," gen_byte_reg =>? error!(start,start+2,"\'in\' is not supported.".to_owned()),
}

quote_in:() ={
    "IN",
    "in",
}

quote_out:() ={
    "OUT",
    "out",
}

pop:() ={
    // reg, seg-reg
    <start:@L> <q:quote_pop> <r:pop_reg> => {
        out.code.push(format!("pop {}",r));
        context.mapper.add_entry(start);
    },
    // mem
    <start:@L> <q:quote_pop> "word" <m:memory_addr> => {
        out.code.push(format!("pop {}",m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_pop> <l:word_label> => {
        out.code.push(format!("pop {}",l));
        context.mapper.add_entry(start);
    },
}

quote_pop:() ={
    "POP",
    "pop",
}

push:() = {
    // reg, seg-reg
    // registers for push is registers of pop + cs
    <start:@L> <q:quote_push> <r:pop_reg> => {
        out.code.push(format!("push {}",r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_push> cs_reg => {
        out.code.push(format!("push cs"));
        context.mapper.add_entry(start);
    },
    // mem
    <start:@L> <q:quote_push> quote_word_length <m:memory_addr> => {
        out.code.push(format!("push {}",m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_push> <l:word_label> => {
        out.code.push(format!("push {}",l));
        context.mapper.add_entry(start);
    },

}

pop_reg:String ={
    gen_word_reg,
    "ES" => "es".to_owned(),
    "es" => "es".to_owned(),
    "DS" => "ds".to_owned(),
    "ds" => "ds".to_owned(),
    "SS" => "ss".to_owned(),
    "ss" => "ss".to_owned(),
}

cs_reg:() = {
    "CS",
    "cs",
}

quote_push:() ={
    "PUSH",
    "push",
}

// even though lds and les only support 16 bit register, as we don't support them, this supports all registers
load_ptr:() ={
    <start:@L> <q:quote_load_ptr> gen_reg "," <m:memory_addr> =>? error!(start,start+3,format!("\'{}\' is not supported",q)),
}

quote_load_ptr:String ={
    "LDS" => "lds".to_owned(),
    "lds" => "lds".to_owned(),
    "LES" => "les".to_owned(),
    "les" => "les".to_owned(),
}

lea:() = {
    <start:@L> <q:quote_lea> <r:gen_word_reg> "," quote_word_length <m:memory_addr> =>{
        out.code.push(format!("lea {} , word {}",r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_lea> <r:gen_word_reg> "," <l:word_label> =>{
        out.code.push(format!("lea {} , word {}",r,l));
        context.mapper.add_entry(start);
    }
}

quote_lea:() ={
    "LEA",
    "lea",
}

// ----------------------------------
// String Instructions

string:() = {
    <start:@L> <q:string_condition_repeat_opcode> => {
        out.code.push(q);
        context.mapper.add_entry(start);
    },
    <start:@L> <q:string_repeat_opcode> =>{
        out.code.push(q);
        context.mapper.add_entry(start);
    },
    string_repeat,
    string_condition_repeat
}

string_repeat:() = {
    <start:@L> quote_repeat <o:string_repeat_opcode> =>{
        out.code.push(format!("rep {}",o));
        context.mapper.add_entry(start);
    },
}

string_condition_repeat:() ={
    <start:@L> <q:quote_condition_repeat> <o:string_condition_repeat_opcode> =>{
        out.code.push(format!("{} {}",q,o));
        context.mapper.add_entry(start);
    },
}

quote_repeat:() ={
    "REP",
    "rep"
}

quote_condition_repeat:String={
    "REPE" => "repz".to_owned(),
    "repe" => "repz".to_owned(),
    "REPZ" => "repz".to_owned(),
    "repz" => "repz".to_owned(),

    "REPNE" => "repnz".to_owned(),
    "repne" => "repnz".to_owned(),
    "REPNZ" => "repnz".to_owned(),
    "repnz" => "repnz".to_owned(),
}

string_condition_repeat_opcode:String = {
    <q:quote_condition_repeat_opcode> quote_byte_length =>{
        format!("{} byte",q)
    },
    <q:quote_condition_repeat_opcode> quote_word_length =>{
        format!("{} word",q)
    },
}

string_repeat_opcode:String = {
    <q:quote_repeat_opcode> quote_byte_length =>{
        format!("{} byte",q)
    },
    <q:quote_repeat_opcode> quote_word_length =>{
        format!("{} word",q)
    },
}


// Instructions used with REP(E/Z/NE/NZ)
quote_condition_repeat_opcode:String ={
    "CMPS" => "cmps".to_owned(),
    "cmps" => "cmps".to_owned(),
    "SCAS" => "scas".to_owned(),
    "scas" => "scas".to_owned(),
}

// Instructions used with REP
quote_repeat_opcode:String = {
    "MOVS" => "movs".to_owned(),
    "movs" => "movs".to_owned(),
    "LODS" => "lods".to_owned(),
    "lods" => "lods".to_owned(),
    "STOS" => "stos".to_owned(),
    "stos" => "stos".to_owned(),
}

// ----------------------------------
// Arithmetic Instructions
arithmetic:() = {
    binary_arithmetic,
    unary_arithmetic,
    singleton_arithmetic,
}

// Following Should work for all instructions that require params of type:
// immediate is signed
// reg,reg
// reg,mem
// mem,reg
// reg,immediate
// mem,immediate
binary_arithmetic:() = {
    // reg,reg
    <start:@L> <q:quote_binary_arithmetic> <r1:gen_byte_reg> "," <r2:gen_byte_reg> =>{
        out.code.push(format!("{} {},{}",q,r1,r2));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <r1:gen_word_reg> "," <r2:gen_word_reg> =>{
        out.code.push(format!("{} {},{}",q,r1,r2));
        context.mapper.add_entry(start);
    },
    //reg,mem
    <start:@L> <q:quote_binary_arithmetic> <r:gen_byte_reg> "," quote_byte_length <m:memory_addr> =>{
        out.code.push(format!("{} {}, byte {}",q,r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <r:gen_word_reg> "," quote_word_length <m:memory_addr> =>{
        out.code.push(format!("{} {}, word {}",q,r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <r:gen_byte_reg> "," <l:byte_label> =>{
        out.code.push(format!("{} {}, byte {}",q,r,l));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <r:gen_word_reg> "," <l:word_label> =>{
        out.code.push(format!("{} {},word {}",q,r,l));
        context.mapper.add_entry(start);
    },
    // mem,reg
    <start:@L> <q:quote_binary_arithmetic> quote_byte_length <m:memory_addr> "," <r:gen_byte_reg> =>{
        out.code.push(format!("{} byte {},{}",q,m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> quote_word_length <m:memory_addr> "," <r:gen_word_reg> =>{
        out.code.push(format!("{} word {},{}",q,m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic>  <l:byte_label> "," <r:gen_byte_reg> =>{
        out.code.push(format!("{} byte {},{}",q,l,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <l:word_label> "," <r:gen_word_reg> =>{
        out.code.push(format!("{} word {},{}",q,l,r));
        context.mapper.add_entry(start);
    },
    //reg , immediate
    <start:@L> <q:quote_binary_arithmetic> <r:gen_byte_reg> "," <n:s_byte_num> =>{
        out.code.push(format!("{} {},{}",q,r,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <r:gen_word_reg> "," <n:s_word_num> =>{
        out.code.push(format!("{} {},{}",q,r,n));
        context.mapper.add_entry(start);
    },
    // mem, immediate
    <start:@L> <q:quote_binary_arithmetic> quote_byte_length <m:memory_addr> "," <n:s_byte_num> =>{
        out.code.push(format!("{} byte {}, {}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> quote_word_length <m:memory_addr> "," <n:s_word_num> =>{
        out.code.push(format!("{} word {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic> <m:byte_label> "," <n:s_byte_num> =>{
        out.code.push(format!("{} byte {}, {}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_arithmetic>  <m:word_label> "," <n:s_word_num> =>{
        out.code.push(format!("{} word {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
}

quote_binary_arithmetic:String = {
    "ADD" => "add".to_owned(),
    "add" => "add".to_owned(),
    "ADC" => "adc".to_owned(),
    "adc" => "adc".to_owned(),
    "SUB" => "sub".to_owned(),
    "sub" => "sub".to_owned(),
    "SBB" => "sbb".to_owned(),
    "sbb" => "sbb".to_owned(),
    "CMP" => "cmp".to_owned(),
    "cmp" => "cmp".to_owned(),
}

singleton_arithmetic:() = {
    <start:@L> <q:quote_singleton_arithmetic> =>{
        out.code.push(format!("{}",q));
        context.mapper.add_entry(start);
    },
}

quote_singleton_arithmetic:String = {
    "AAA" => "aaa".to_owned(),
    "aaa" => "aaa".to_owned(),
    "AAD" => "aad".to_owned(),
    "aad" => "aad".to_owned(),
    "AAM" => "aam".to_owned(),
    "aam" => "aam".to_owned(),
    "AAS" => "aas".to_owned(),
    "aas" => "aas".to_owned(),
    "DAA" => "daa".to_owned(),
    "daa" => "daa".to_owned(),
    "DAS" => "das".to_owned(),
    "das" => "das".to_owned(),
    "CBW" => "cbw".to_owned(),
    "cbw" => "cbw".to_owned(),
    "CWD" => "cwd".to_owned(),
    "cwd" => "cwd".to_owned(),
}

unary_arithmetic:() = {
    <start:@L> <q:quote_unary_arithmetic> <r:gen_reg> =>{
        out.code.push(format!("{} {}",q,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_unary_arithmetic> quote_byte_length <m:memory_addr> =>{
        out.code.push(format!("{} byte {}",q,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_unary_arithmetic> quote_word_length <m:memory_addr> =>{
        out.code.push(format!("{} word {}",q,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_unary_arithmetic> <l:byte_label> =>{
        out.code.push(format!("{} byte {}",q,l));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_unary_arithmetic> <l:word_label> =>{
        out.code.push(format!("{} word {}",q,l));
        context.mapper.add_entry(start);
    },
}

quote_unary_arithmetic:String = {
    "DEC" => "dec".to_owned(),
    "dec" => "dec".to_owned(),
    "INC" => "inc".to_owned(),
    "inc" => "inc".to_owned(),
    "NEG" => "neg".to_owned(),
    "neg" => "neg".to_owned(),
    "MUL" => "mul".to_owned(),
    "mul" => "mul".to_owned(),
    "IMUL" => "imul".to_owned(),
    "imul" => "imul".to_owned(),
    "DIV" => "div".to_owned(),
    "div" => "div".to_owned(),
    "IDIV" => "idiv".to_owned(),
    "idiv" => "idiv".to_owned(),


}

// ----------------------------------
// Bit Manipulation Instructions

bit_manipulation:() = {
    not,
    binary_logical,
    shift_rotate,
}

 not:()={
    <start:@L> quote_not <r:gen_reg> =>{
        out.code.push(format!("not {}",r));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_not quote_byte_length <m:memory_addr> =>{
        out.code.push(format!("not byte {}",m));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_not quote_word_length <m:memory_addr> =>{
        out.code.push(format!("not word {}",m));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_not <m:word_label> =>{
        out.code.push(format!("not word {}",m));
        context.mapper.add_entry(start);
    },
    <start:@L> quote_not <m:byte_label> =>{
        out.code.push(format!("not byte {}",m));
        context.mapper.add_entry(start);
    },
}

quote_not:() = {
    "NOT",
    "not"
}

// Following Should work for all instructions that require params of type:
// immediate is unsigned
// reg,reg
// reg,mem
// mem,reg
// reg,immediate
// mem,immediate
binary_logical:() = {
    // reg,reg
    <start:@L> <q:quote_binary_logical> <r1:gen_byte_reg> "," <r2:gen_byte_reg> =>{
        out.code.push(format!("{} {},{}",q,r1,r2));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <r1:gen_word_reg> "," <r2:gen_word_reg> =>{
        out.code.push(format!("{} {},{}",q,r1,r2));
        context.mapper.add_entry(start);
    },
    //reg,mem
    <start:@L> <q:quote_binary_logical> <r:gen_byte_reg> "," quote_byte_length <m:memory_addr> =>{
        out.code.push(format!("{} {}, byte {}",q,r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <r:gen_word_reg> "," quote_word_length <m:memory_addr> =>{
        out.code.push(format!("{} {}, word {}",q,r,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <r:gen_byte_reg> "," <l:byte_label> =>{
        out.code.push(format!("{} {}, byte {}",q,r,l));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <r:gen_word_reg> "," <l:word_label> =>{
        out.code.push(format!("{} {},word {}",q,r,l));
        context.mapper.add_entry(start);
    },
    // mem,reg
    <start:@L> <q:quote_binary_logical> quote_byte_length <m:memory_addr> "," <r:gen_byte_reg> =>{
        out.code.push(format!("{} byte {},{}",q,m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> quote_word_length <m:memory_addr> "," <r:gen_word_reg> =>{
        out.code.push(format!("{} word {},{}",q,m,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical>  <l:byte_label> "," <r:gen_byte_reg> =>{
        out.code.push(format!("{} byte {},{}",q,l,r));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <l:word_label> "," <r:gen_word_reg> =>{
        out.code.push(format!("{} word {},{}",q,l,r));
        context.mapper.add_entry(start);
    },
    //reg , immediate
    <start:@L> <q:quote_binary_logical> <r:gen_byte_reg> "," <n:u_byte_num> =>{
        out.code.push(format!("{} {},{}",q,r,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <r:gen_word_reg> "," <n:u_word_num> =>{
        out.code.push(format!("{} {},{}",q,r,n));
        context.mapper.add_entry(start);
    },
    // mem, immediate
    <start:@L> <q:quote_binary_logical> quote_byte_length <m:memory_addr> "," <n:u_byte_num> =>{
        out.code.push(format!("{} byte {}, {}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> quote_word_length <m:memory_addr> "," <n:u_word_num> =>{
        out.code.push(format!("{} word {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical> <m:byte_label> "," <n:u_byte_num> =>{
        out.code.push(format!("{} byte {}, {}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_binary_logical>  <m:word_label> "," <n:u_word_num> =>{
        out.code.push(format!("{} word {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
}
quote_binary_logical:String = {
    "AND" => "and".to_owned(),
    "and" => "and".to_owned(),
    "OR" => "or".to_owned(),
    "or" => "or".to_owned(),
    "XOR" => "xor".to_owned(),
    "xor" => "xor".to_owned(),
    //verify test
    "TEST" => "test".to_owned(),
    "test" => "test".to_owned(),
}


shift_rotate:() = {
    // register
    <start:@L> <q:quote_shift_rotate> <r:gen_reg> "," <n:u_byte_num> => {
        out.code.push(format!("{} {},{}",q,r,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_shift_rotate> <r:gen_reg> "," reg_cl => {
        out.code.push(format!("{} {}, cl",q,r));
        context.mapper.add_entry(start);
    },

    // memory
    <start:@L> <q:quote_shift_rotate> quote_byte_length <m:memory_addr> "," <n:u_byte_num> => {
        out.code.push(format!("{} byte {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_shift_rotate> quote_byte_length <m:memory_addr> "," reg_cl => {
        out.code.push(format!("{} byte {},cl",q,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_shift_rotate> quote_word_length <m:memory_addr> "," <n:u_byte_num> => {
        out.code.push(format!("{} word {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_shift_rotate> quote_word_length <m:memory_addr> "," reg_cl => {
        out.code.push(format!("{} word {},cl",q,m));
        context.mapper.add_entry(start);
    },
    // label
    <start:@L> <q:quote_shift_rotate> <m:byte_label> "," <n:u_byte_num> => {
        out.code.push(format!("{} {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
    // Support byte_num only as anyway 256 will clear out the 16 bit number
    <start:@L> <q:quote_shift_rotate> <m:word_label> "," <n:u_byte_num> => {
        out.code.push(format!("{} {},{}",q,m,n));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_shift_rotate> <m:byte_label> "," reg_cl => {
        out.code.push(format!("{} {}, cl",q,m));
        context.mapper.add_entry(start);
    },
    <start:@L> <q:quote_shift_rotate> <m:word_label> "," reg_cl => {
        out.code.push(format!("{} {}, cl",q,m));
        context.mapper.add_entry(start);
    },
}


quote_shift_rotate:String = {
    "SAL" => "sal".to_owned(),
    "sal" => "sal".to_owned(),
    "SHL" => "sal".to_owned(),
    "shl" => "sal".to_owned(),
    "SAR" => "sar".to_owned(),
    "sar" => "sar".to_owned(),
    "SHR" => "shr".to_owned(),
    "shr" => "shr".to_owned(),
    "ROL" => "rol".to_owned(),
    "rol" => "rol".to_owned(),
    "ROR" => "ror".to_owned(),
    "ror" => "ror".to_owned(),
    "RCL" => "rcl".to_owned(),
    "rcl" => "rcl".to_owned(),
    "RCR" => "rcr".to_owned(),
    "rcr" => "rcr".to_owned(),
}


// ----------------------------------
// Transfer Instructions

transfer:() = {
    call,
    ret,
    jmps_loops,
    int,
}


call:() = {
    <start:@L> quote_call <n:name_string> <end:@R> =>?{
        if !context.fn_map.contains_key(&n){
            return error!(start,end,format!("\'call\' can be only used with procedures, {} is not a procedure",n));
        }else{
            out.code.push(format!("call {}",n));
            context.mapper.add_entry(start);
            return Ok(());
        }
        
    },
}
quote_call:()={
    "CALL",
    "call"
}

ret:() = {
    <start:@L> quote_ret <end:@R> =>{
        out.code.push("ret".to_owned());
        context.mapper.add_entry(start);        
    }
}

quote_ret:() = {
    "RET",
    "ret"
}

int:() = {
    <start:@L> quote_int <n:u_byte_num> <end:@R> =>?{
        if n==3 || n == 0x10 || n == 0x21{
            out.code.push(format!("int {}",n));
            context.mapper.add_entry(start);
            Ok(())
        }else{
            error!(start,end,"\'int\' only supports 0x3,0x10 and 0x21".to_owned())
        }
    }
}

quote_int:() = {
    "INT",
    "int"
}

into_iret:() = {
    <start:@L> <q:quote_into_iret> <end:@R> =>?{
        error!(start,end,format!("\'{}\' is not supported",q))
    }
}

quote_into_iret:String = {
    "INTO" => "into".to_owned(),
    "into" => "into".to_owned(),
    "IRET" => "iret".to_owned(),
    "iret" => "iret".to_owned(),
}


// All jumps and loops are combined in single, as they have same syntax
jmps_loops:() = {
    <start:@L> <q:quote_jmps_loops> <n:name_string><end:@R> =>{
        out.code.push(format!("{} {}",q,n));
        context.mapper.add_entry(start);
        if !context.label_map.contains_key(&n){
            context.undefined_labels.insert((start,n));
        }
        
    }
}

quote_jmps_loops:String = {
    "JMP" => "jmp".to_owned(),
    "jmp" => "jmp".to_owned(),

    // ja and jnbe both are same for execution
    "JA" => "ja".to_owned(),
    "ja" => "ja".to_owned(),
    "JNBE" => "ja".to_owned(),
    "jnbe" => "ja".to_owned(),

    // jae and jnb are same for execution
    "JAE" => "jae".to_owned(),
    "jae" => "jae".to_owned(),
    "JNB" => "jae".to_owned(),
    "jnb" => "jae".to_owned(),

    // jb and jnae are same for execution
    "JB" => "jb".to_owned(),
    "jb" => "jb".to_owned(),
    "JNAE" => "jb".to_owned(),
    "jnae" => "jb".to_owned(),

    // jbe and jna are same for execution
    "JBE" => "jbe".to_owned(),
    "jbe" => "jbe".to_owned(),
    "JNA" => "jna".to_owned(),
    "jna" => "jna".to_owned(),


    "JC" => "jc".to_owned(),
    "jc" => "jc".to_owned(),

    // je and jz are same for execution
    "JE" => "je".to_owned(),
    "je" => "je".to_owned(),
    "JZ" => "je".to_owned(),
    "jz" => "je".to_owned(),

    // jg and jnle are same for execution
    "JG" => "jg".to_owned(),
    "jg" => "jg".to_owned(),
    "JNLE" => "jg".to_owned(),
    "jnle" => "jg".to_owned(),

    // jge and jnl are same in execution
    "JGE" => "jge".to_owned(),
    "jge" => "jge".to_owned(),
    "JNL" => "jge".to_owned(),
    "jnl" => "jge".to_owned(),

    // jl and jnge are same in execution
    "JL" => "jl".to_owned(),
    "jl" => "jl".to_owned(),
    "JNGE" => "jl".to_owned(),
    "jnge" => "jl".to_owned(),

    // jle and jng are same in execution
    "JLE" => "jle".to_owned(),
    "jle" => "jle".to_owned(),
    "JNG" => "jle".to_owned(),
    "jng" => "jle".to_owned(),

    "JNC" => "jnc".to_owned(),
    "jnc" => "jnc".to_owned(),

    // jne and jnz are same in execution
    "JNE" => "jne".to_owned(),
    "jne" => "jne".to_owned(),
    "JNZ" => "jne".to_owned(),
    "jnz" => "jne".to_owned(),
    
    "JNO" => "jno".to_owned(),
    "jno" => "jno".to_owned(),

    // jnp and jpo are same in execution
    "JNP" => "jnp".to_owned(),
    "jnp" => "jnp".to_owned(),
    "JPO" => "jnp".to_owned(),
    "jpo" => "jnp".to_owned(),


    "JNS" => "jns".to_owned(),
    "jns" => "jns".to_owned(),
    "JO" => "jo".to_owned(),
    "jo" => "jo".to_owned(),

    // jp and jpe are same in execution
    "JP" => "jp".to_owned(),
    "jp" => "jp".to_owned(),
    "JPE" => "jp".to_owned(),
    "jpe" => "jp".to_owned(),


    "JS" => "js".to_owned(),
    "js" => "js".to_owned(),

    "JCXZ" => "jcxz".to_owned(),
    "jcxz" => "jcxz".to_owned(),

    "LOOP" => "loop".to_owned(),
    "loop" => "loop".to_owned(),

    // loope and loopz are same in execution
    "LOOPE" => "loope".to_owned(),
    "loope" => "loope".to_owned(),
    "LOOPZ" => "loope".to_owned(),
    "loopz" => "loope".to_owned(),

    // loopne and loopnz are same in execution
    "LOOPNE" => "loopne".to_owned(),
    "loopne" => "loopne".to_owned(),
    "LOOPNZ" => "loopne".to_owned(),
    "loopnz" => "loopne".to_owned(),   
}

// ----------------------------------
// Control Instructions

control:()={
    control_supported,
    control_unsupported
    nop
}

control_supported:() ={
    <start:@L> <q:quote_control_supported> =>{out.code.push(format!("{}",q));context.mapper.add_entry(start);},
}

quote_control_supported:String = {
    "STC" => "stc".to_owned(),
    "stc" => "stc".to_owned(),
    "CLC" => "clc".to_owned(),
    "clc" => "clc".to_owned(),
    "CMC" => "cmc".to_owned(),
    "cmc" => "cmc".to_owned(),
    "STD" => "std".to_owned(),
    "std" => "std".to_owned(),
    "CLD" => "cld".to_owned(),
    "cld" => "cld".to_owned(),
    "STI" => "sti".to_owned(),
    "sti" => "sti".to_owned(),
    "CLI" => "cli".to_owned(),
    "cli" => "cli".to_owned(),
    "HLT" => "hlt".to_owned(),
    "hlt" => "hlt".to_owned(),

}

control_unsupported:() ={
    <start:@L> <q:quote_control_unsuppoted> <end:@R> =>?error!(start,end,format!("\'{}\' is not supported.",q)),
}

quote_control_unsuppoted:String ={
    "WAIT" => "wait".to_owned(),
    "wait" => "wait".to_owned(),
    "ESC" => "esc".to_owned(),
    "esc" => "esc".to_owned(),
    "LOCK" => "lock".to_owned(),
    "lock" => "lock".to_owned(),
}

nop:()={
    <start:@L> "NOP" =>,
    <start:@L> "nop" =>
}


// ---------------------------------------------------------------------------------------------


// Low Level non-Terminals

// Label
// syntax : string immediately followed by a ':'
label:String = {
    <start:@L> <s:r"[_a-zA-Z][_a-zA-Z0-9]*:"> =>?{
        match context.label_map.get(&s[0..s.len()-1]){
            Some(l) => return error!(l.source_position as usize,l.source_position as usize+s.len(),format!("Label {} Already defined",s)),
            None => {
                context.label_map.insert(s[0..s.len()-1].to_owned(),Label::new(LabelType::CODE,start,out.code.len()));
                Ok(s[0..s.len()-1].to_owned())
            }
        }
    }
}


// Used to denote a 16-bit number
// can be a binary, decimal or hexadecimal number
// all are converted to u16
u_word_num: u16 = {
    // Decimal

    <start:@L> <n:r"[0-9]+"> <end:@R> =>? {
        match u16::from_str_radix(n,10){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-65535".to_owned())
        }
    },

    // hexadecimal
    <start:@L> <n:r"0(x|X)[0-9A-Fa-f]+"> <end:@R> =>? {
        match u16::from_str_radix(&n[2..],16){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-65535".to_owned())
        }
    },

    // Binary
    <start:@L> <n:r"0(b|B)[0-1]+"> <end:@R> =>? {
        match u16::from_str_radix(&n[2..],2){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-65535".to_owned())
        }
    },
    offset
}


// Used to denote a 8-bit number
// can be a binary, decimal or hexadecimal number
// all are converted to u16
u_byte_num: u8 = {
    // Decimal
    <start:@L> <n:r"[0-9]+"> <end:@R> =>? {
        match u8::from_str_radix(n,10){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-255".to_owned())
        }
    },

    // hexadecimal
    <start:@L> <n:r"0(x|X)[0-9A-Fa-f]+"> <end:@R> =>? {
        match u8::from_str_radix(&n[2..],16){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-255".to_owned())
        }
    },

    // Binary
    <start:@L> <n:r"0(b|B)[0-1]+"> <end:@R> =>? {
        match u8::from_str_radix(&n[2..],2){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-255".to_owned())
        }
    },
    <start:@L> <o:offset> <end:@R> =>?{
        if o > 255{
            error!(start,end,format!("Offset is greater than 255"))
        }else{
            Ok(o as u8)
        }
    }
}


s_word_num: i16 = {
    // Decimal

    <start:@L> <n:r"-[0-9]+"> <end:@R> =>? {
        match i16::from_str_radix(n,10){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-65535".to_owned())
        }
    },
    <n:u_word_num> => n as i16
}


// Used to denote a 8-bit number
// can be a binary, decimal or hexadecimal number
// all are converted to u16
s_byte_num: i8 = {
    // Decimal
    <start:@L> <n:r"-[0-9]+"> <end:@R> =>? {
        match i8::from_str_radix(n,10){
            Ok(v) => Ok(v),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-255".to_owned())
        }
    },
    <n:u_byte_num> => n as i8
}


raw_addr: u32 = {
    // Decimal
    <start:@L> <n:r"[0-9]+"> <end:@R> =>? {
        match u32::from_str_radix(n,10){
            Ok(v) => Ok(v%MB),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-1048576".to_owned())
        }
    },

    // hexadecimal
    <start:@L> <n:r"0(x|X)[0-9A-Fa-f]+"> <end:@R> =>? {
        match u32::from_str_radix(&n[2..],16){
            Ok(v) => Ok(v%MB),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-1048576".to_owned())
        }
    },

    // Binary
    <start:@L> <n:r"0(b|B)[0-1]+"> <end:@R> =>? {
        match u32::from_str_radix(&n[2..],2){
            Ok(v) => Ok(v%MB),
            Err(_) => error!(start,end,"Invalid Value, must be between 0-1048576".to_owned())
        }
    },
    <o:offset> =>{
       o as u32
    }
}


offset:u16 = {
    <start:@L> quote_offset  <n:name_string> <end:@R> =>?{
        match context.label_map.get(&n){
            Some(l)=>{
                match l.get_type(){
                    LabelType::CODE => {error!(start,end,format!("\'offset\' can be used only with data labels, {} is not a data label",n))}
                    LabelType::DATA => {return Ok(l.map as u16);}
                }
            }
            None => {error!(start,end,format!("Label {} is not declared.",n))}
        }
    }
}

quote_offset:() = {
    "OFFSET",
    "offset"
}

// ---------------------------------------------------------------------------------------------

// Helpers

gen_reg:String = {
    gen_byte_reg,
    gen_word_reg
}

gen_byte_reg:String = {
    "AH" => "ah".to_owned(),
    "ah" => "ah".to_owned(),
    "AL" => "al".to_owned(),
    "al" => "al".to_owned(),
    "BH" => "bh".to_owned(),
    "bh" => "bh".to_owned(),
    "BL" => "bl".to_owned(),
    "bl" => "bl".to_owned(),
    "CH" => "ch".to_owned(),
    "ch" => "ch".to_owned(),
    reg_cl,
    "DH" => "dh".to_owned(),
    "dh" => "dh".to_owned(),
    "DL" => "dl".to_owned(),
    "dl" => "dl".to_owned(),
}

reg_cl:String = {
    "CL" => "cl".to_owned(),
    "cl" => "cl".to_owned(),
}

gen_word_reg:String = {
    
    "AX" => "ax".to_owned(),
    "ax" => "ax".to_owned(),
    base_index_reg,
    "sp" => "sp".to_owned(),
    "SP" => "sp".to_owned(),
    "CX" => "cx".to_owned(),
    "cx" => "cx".to_owned(),
    "DX" => "dx".to_owned(),
    "dx" => "dx".to_owned(),
}

base_index_reg:String = {
    base_reg,
    index_reg,
}

base_reg:String = {
    "BX" => "bx".to_owned(),
    "bx" => "bx".to_owned(),
    "BP" => "bp".to_owned(),
    "bp" => "bp".to_owned(),
}

index_reg:String = {
    "SI" => "si".to_owned(),
    "si" => "si".to_owned(),
    "DI" => "di".to_owned(),
    "di" => "di".to_owned(),
}

memory_addr:String = {
    // direct addressing
    "[" <n:u_word_num> "]" => format!("[{}]",n),
    // Register Indirect
    "[" <r:base_index_reg> "]" => format!("[{}]",r),
    // Based
    "[" <r:base_reg> "," <n:s_word_num> "]" => format!("[{},{}]",r,n),
    // indexed
    "[" <r:index_reg> "," <n:s_word_num> "]" => format!("[{},{}]",r,n),
    //based indexed
    "[" <b:base_reg> "," <i:index_reg> <k:("," <s_word_num>)?> "]" => {
        match k{
            Some(n) => format!("[{},{},{}]",b,i,n),
            None => format!("[{},{},{}]",b,i,0),
        }
    },
}

byte_label:String = {
    <start:@L> <l:quote_byte_length> <n:name_string> <end:@R> =>? {
        match context.label_map.get(&n){
            None => {return error!(start,end,format!("Label {} not defined",n));},
            Some(l) => {
                match l.get_type() {
                    LabelType::CODE => {return error!(start,end,format!("Cannot use Code label {}",n));}
                    LabelType::DATA =>{}
                }
            } 
        } 
        Ok(n)
    }
}

word_label:String = {
    <start:@L> <l:quote_word_length> <n:name_string> <end:@R> =>? {
        match context.label_map.get(&n){
            None => {return error!(start,end,format!("Label {} not defined",n));},
            Some(l) => {
                match l.get_type() {
                    LabelType::CODE => {return error!(start,end,format!("Cannot use Code label {}  ",n));}
                    LabelType::DATA =>{}
                }
            } 
        } 
        Ok(n)
    }
}

quote_byte_length:String = {
    "BYTE" => "byte".to_owned(),
    "byte" => "byte".to_owned(),
}

quote_word_length:String = {
    "WORD" => "word".to_owned(),
    "word" => "word".to_owned(),
}


CommaSepList<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

name_string:String ={
    <v:r"[_a-zA-Z][_a-zA-Z0-9]*"> =>{
        v.to_owned()
    }
}

general_string:String = {
    name_string,
    <n:u_word_num> =>format!("{}",n)
}